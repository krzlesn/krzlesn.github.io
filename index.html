<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Krzysztof Leśniewski</title>

  <!-- Uwaga: JEŚLI to jest projekt pod ścieżką /lesniewskik/ na GitHub Pages,
       możesz odkomentować bazę: -->
  <!-- <base href="/lesniewskik/"> -->



  <link rel="stylesheet" href="main.css" />
<style>
  /* CANVAS nad tłem strony, ale pod treścią */
  #glbg{ position:fixed; inset:0; z-index:0; display:block; }

  /* “mgiełka” nad CANVAS, nadal pod treścią */
  .frost-overlay{
    position:fixed; inset:0; pointer-events:none; z-index:1;
    background:
      radial-gradient(1200px 800px at 110% -10%, rgba(255,255,255,.10), transparent 55%),
      radial-gradient(900px 700px at -10% 0%, rgba(255,255,255,.10), transparent 60%);
  }

  /* treść zawsze NA WIERZCHU */
  .site-header, .site-nav, .container, .site-footer{
    position: relative; z-index: 2;
  }

  /* jeżeli ktoś wyłączył animacje */
  @media (prefers-reduced-motion: reduce){
    #glbg{ display:none; }
  }
</style>
  <!-- MathJax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
    MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
  </script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <canvas id="glbg" aria-hidden="true"></canvas>
<div class="frost-overlay" aria-hidden="true"></div>
  <header class="site-header">
    <h1 class="site-title">Krzysztof Leśniewski</h1>
    <p class="site-subtitle">Matematyka • Analiza • Optymalizacja test aktualizacji4</p>

  </header>

  <nav class="site-nav">
    <ul>
      <li><a href="analiza-mini2.html">Analiza — do poczytania</a></li>
      <li><a href="https://1drv.ms/f/s!Amza0q5wjUyNgc14zwWl6u3LFDd3Zw?e=gEP4LU">DDE (NEW)</a></li>
      <li><a href="DDE.html">DDE (OLD)</a></li>
      <li><a href="https://1drv.ms/f/s!Amza0q5wjUyNgc15ik32yVouH-sDQA?e=bpPELh">Analiza I — stacjonarne WIL</a></li>
      <li><a href="https://1drv.ms/f/s!Amza0q5wjUyNgc1JRomNFHlhP9C_Dg?e=SGXQw8">Analiza I — zadania WIL</a></li>
      <li><a href="https://1drv.ms/u/s!Amza0q5wjUyNgaUdr5i74CyqVB1BKg?e=xmRhZC">Analiza I — niestacjonarne WIL</a></li>
      <li><a href="#">Calculus I</a></li>
      <li><a href="https://www.researchgate.net/profile/Krzysztof_Lesniewski2">Articles</a></li>
      <!-- przykładowy PDF trzymany lokalnie w repo: -->
      <li><a href="pdfs/zadania01.pdf">Zadania 01 (PDF)</a></li>
    </ul>
  </nav>

  <main class="container">
    <section class="card">
      <h2>Witaj!</h2>
      <p>
        Tu będą materiały do zajęć, zadania (PDF), krótkie notatki z LaTeX-em
        i odnośniki. Przykład wzoru:
      </p>
      <p>
        $$ \nabla f(x^*) = 0,\quad H_f(x^*) \succeq 0. $$
      </p>
    </section>

    <section class="card">
      <h3>Kontakt</h3>
      <p>
        <a href="mailto:k.lesniewski">k.lesniewski</a> ·
        <a href="https://mini.pw.edu.pl">mini.pw.edu.pl</a> ·
        <a href="http://www.ibspan.waw.pl/">ibspan.waw.pl</a>
      </p>
    </section>
  </main>

  <footer class="site-footer">
    <small>&copy; <span id="year"></span> Krzysztof Leśniewski</small>
  </footer>

  <script>
    // Rok w stopce
    document.getElementById('year').textContent = new Date().getFullYear();
  </script>
 <script type="module">
import { SwissGL } from "https://google.github.io/swissgl/swissgl.js";

const canvas = document.getElementById('glbg');

function fitCanvas(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const w = innerWidth, h = innerHeight;
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";
  return dpr;
}
let dpr = fitCanvas();
addEventListener('resize', () => dpr = fitCanvas(), { passive:true });

const params = {
  speed: 0.08,       // prędkość
  density: 1.9,      // gęstość struktur
  tint: [0.53,0.66,0.75],
  strength: 0.35
};

const reduceMotion = matchMedia('(prefers-reduced-motion: reduce)').matches;

// --- Spróbuj SwissGL (WebGL2) ---
let gl = null;
try {
  gl = new SwissGL(canvas);
} catch (e) {
  console.warn("WebGL2 unavailable, will use Canvas 2D fallback.", e);
}

if (!reduceMotion && gl) {
  // WebGL2 wariant (ładniejsze „kaustyki”)
  let t0 = performance.now();
  function frameGL(){
    const t = (performance.now() - t0) * 0.001 * params.speed;
    gl({
      frag: `
      out vec4 fragColor;
      float hash(vec2 p){ return fract(sin(dot(p, vec2(41.0, 289.0)))*43758.5453); }
      float noise(vec2 p){
        vec2 i = floor(p), f = fract(p);
        float a = hash(i), b = hash(i+vec2(1,0)), c = hash(i+vec2(0,1)), d = hash(i+vec2(1,1));
        vec2 u = f*f*(3.0-2.0*f);
        return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
      }
      float fbm(vec2 p){
        float s=0.0,a=0.5;
        for(int i=0;i<5;i++){ s+=a*noise(p); p*=1.9; a*=0.55; }
        return s;
      }
      void main(){
        vec2 R = iResolution.xy, uv = (gl_FragCoord.xy/R)-.5; uv.x *= R.x/R.y;
        float n = fbm(uv*${params.density.toFixed(2)} + vec2(iTime*0.6, -iTime*0.4));
        float c = smoothstep(0.35, 0.95, n);
        c = pow(c, 1.6) * ${params.strength.toFixed(2)};
        vec3 tint = vec3(${params.tint.join(",")}), base = vec3(0.97,0.98,0.99);
        vec3 col = mix(base, tint, c);
        float r = length(uv); col *= 1.0 - 0.06 * smoothstep(0.35, 0.9, r);
        fragColor = vec4(col,1.0);
      }`,
      uniforms: { iTime: t, iResolution: [canvas.width, canvas.height, 1] },
      pipeline: true
    });
    requestAnimationFrame(frameGL);
  }
  frameGL();
} else {
  // --- Fallback: Canvas 2D — „lodowe fale” bez WebGL ---
  const ctx = canvas.getContext('2d');
  let t0 = performance.now();

  function noise2D(x, y){
    // bardzo prosty, szybki „szum” (bez zależności) – wystarczy jako tło
    return Math.sin(x*1.3 + Math.cos(y*1.7)) * 0.5 + Math.sin(y*0.7 - x*0.9) * 0.5;
  }

  function frame2D(){
    const t = (performance.now() - t0) * 0.001 * params.speed;
    const W = canvas.width, H = canvas.height;
    const scale = 0.002 * params.density;      // gęstość
    const amp = 90 * params.strength;          // siła efektu

    // rysujemy w paskach – szybciej niż piksel po pikselu
    const stepY = Math.max(2, Math.floor(H / 180));
    for (let y = 0; y < H; y += stepY) {
      // odcień lodowy z lekką modulacją
      const n = noise2D(0, (y + t*120) * scale);
      const base = 250, tint = 200; // jasna baza + zimny tint
      const r = Math.max(230, Math.min(255, base - amp*0.15 + n*8));
      const g = Math.max(235, Math.min(255, base - amp*0.10 + n*10));
      const b = Math.max(240, Math.min(255, tint + amp*0.08 + n*18));

      ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
      ctx.fillRect(0, y, W, stepY);
    }

    if (!reduceMotion) requestAnimationFrame(frame2D);
  }

  frame2D();
}
</script>
</body>
</html>
